// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	sl "github.com/scionproto/scion/verification/utils/slices"
	"github.com/scionproto/scion/verification/io"
	"github.com/scionproto/scion/verification/dependencies/encoding/binary"
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/pkg/slayers/path/scion"
)

ghost 
decreases 
pure func numInfoFields(seg1Len int, seg2Len int, seg3Len int) int {
	return seg3Len > 0 ? 3 : (seg2Len > 0 ? 2 : 1)
}

ghost 
decreases
pure func hopFieldOffset(numINF int, currHF int) int {
	return path.InfoFieldOffset(numINF) + path.HopLen * currHF
}

ghost 
decreases
pure func pktLen(seg1Len int, seg2Len int, seg3Len int) int {
	return hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) + 
        path.HopLen * (seg1Len + seg2Len + seg3Len)
}


ghost 
decreases
pure func lengthOfCurrSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) int {
	return seg1Len > currHF ? seg1Len : ((seg1Len + seg2Len) > currHF ? seg2Len : seg3Len)
}

ghost 
requires 0 <= currHF
ensures  res <= currHF
decreases
pure func lengthOfPrevSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) (res int) {
	return seg1Len > currHF ? 0 : ((seg1Len + seg2Len) > currHF ? seg1Len : seg1Len + seg2Len)
}

// returns the ASid of a hopfield
ghost
requires 1 <= numINF
requires 0 <= currHFIdx
requires 0 <= length && length <= len(raw)
requires hopFieldOffset(numINF, currHFIdx) + path.HopLen <= length
requires dp.Valid()
requires let idx := hopFieldOffset(numINF, currHFIdx) in
	acc(&raw[idx+2], _) && acc(&raw[idx+3], _) && acc(&raw[idx+4], _) && acc(&raw[idx+5], _)
decreases
pure func asidFromIfs(
    dp io.DataPlaneSpec, 
    raw []byte, 
    numINF int, 
    currHFIdx int, 
    consDir bool, 
    asid io.IO_as, 
	length int) (res option[io.IO_as]) {
	return let idx := hopFieldOffset(numINF, currHFIdx) in
		let ifs := consDir ? binary.BigEndian.Uint16(raw[idx+4:idx+6]) : binary.BigEndian.Uint16(raw[idx+2:idx+4]) in
		let asIfPair := io.AsIfsPair{asid, io.IO_ifs(ifs)} in
		(asIfPair in domain(dp.GetLinks()) ?
			some(dp.Lookup(asIfPair).asid) : none[io.IO_as])
}

// returns a list of ASids of hopfields that are before the current hopfield in a segment
ghost
requires 1 <= numINF
requires 0 <= prevSegLen && prevSegLen <= currHFIdx
requires 0 <= length && length <= len(raw)
requires hopFieldOffset(numINF, currHFIdx) + path.HopLen <= length
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures res != none[seq[io.IO_as]] ==> len(get(res)) == currHFIdx - prevSegLen + 1
decreases currHFIdx - prevSegLen
pure func asidsBefore(
    dp io.DataPlaneSpec, 
    raw []byte, 
    numINF int, 
    currHFIdx int, 
    prevSegLen int, 
    consDir bool, 
    asid io.IO_as, 
	length int) (res option[seq[io.IO_as]]) {
	return let next_asid := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in asidFromIfs(dp, raw, numINF, currHFIdx, !consDir, asid, length)) in 
		match next_asid{
			case none[io.IO_as]:
				none[seq[io.IO_as]]
			default: 
				currHFIdx == prevSegLen ? some(seq[io.IO_as]{get(next_asid)}) : 
				let next_asid_seq := asidsBefore(dp, raw, numINF, currHFIdx-1, prevSegLen, consDir, get(next_asid), length) in 
				match next_asid_seq{
					case none[seq[io.IO_as]]:
						none[seq[io.IO_as]]
					default:
						some(get(next_asid_seq) ++ seq[io.IO_as]{get(next_asid)})
				}
		}
}

// returns a list of ASids of hopfields that are after the current hopfield in a segment
ghost
requires 1 <= numINF
requires 0 <= currHFIdx && currHFIdx < segLen
requires 0 <= length && length <= len(raw)
requires hopFieldOffset(numINF, segLen) <= length
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures res != none[seq[io.IO_as]] ==> len(get(res)) == segLen - currHFIdx
decreases segLen - currHFIdx + 1
pure func asidsAfter(
    dp io.DataPlaneSpec, 
    raw []byte, 
    numINF int, 
    currHFIdx int, 
    segLen int, 
    consDir bool, 
    asid io.IO_as, 
	length int) (res option[seq[io.IO_as]]) {
	return let next_asid := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in asidFromIfs(dp, raw, numINF, currHFIdx, consDir, asid, length)) in 
        match next_asid{
            case none[io.IO_as]:
                none[seq[io.IO_as]]
            default: 
                currHFIdx == segLen - 1 ? some(seq[io.IO_as]{get(next_asid)}) : 
                let next_asid_seq := asidsAfter(dp, raw, numINF, currHFIdx+1, segLen, consDir, get(next_asid), length) in 
                match next_asid_seq{
                    case none[seq[io.IO_as]]:
                        none[seq[io.IO_as]]
                    default:
                        some(seq[io.IO_as]{get(next_asid)} ++ get(next_asid_seq))
                }
        }
}

// returns a list of ASids of hopfields for CurrSeg in the abstract packet
ghost
requires 1 <= numINF
requires 0 <= prevSegLen && prevSegLen <= currHFIdx
requires currHFIdx < segLen
requires 0 <= length && length <= len(raw)
requires hopFieldOffset(numINF, segLen) <= length
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures res != none[seq[io.IO_as]] ==> len(get(res)) == segLen - prevSegLen
decreases
pure func asidForCurrSeg(
    dp io.DataPlaneSpec, 
    raw []byte, 
    numINF int, 
    currHFIdx int, 
    segLen int, 
    prevSegLen int, 
    consDir bool, 
    asid io.IO_as, 
	length int) (res option[seq[io.IO_as]]) {
	return segLen == 0 ? some(seq[io.IO_as]{}) : 
		let left := asidsBefore(dp, raw, numINF, currHFIdx, prevSegLen, consDir, asid, length) in
		let right := asidsAfter(dp, raw, numINF, currHFIdx, segLen, consDir, asid, length) in
		(left == none[seq[io.IO_as]] || right == none[seq[io.IO_as]]) ?
			none[seq[io.IO_as]] : 
			some(get(left) ++ get(right)[1:])
}

// returns a list of ASids of hopfields for LeftSeg in the abstract packet
ghost
requires dp.Valid()
requires 1 <= numINF
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires 0 <= length && length <= len(raw)
requires hopFieldOffset(numINF, seg1Len + seg2Len + seg3Len) <= length
requires currINFIdx <= numINF + 1
requires 1 <= currINFIdx && currINFIdx < 4
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
decreases
pure func asidsForLeftSeg(dp io.DataPlaneSpec, raw []byte, numINF int, currINFIdx int, seg1Len int, seg2Len int, seg3Len int, asid io.IO_as, length int) (res option[seq[io.IO_as]]) {
	return let consDir := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in path.ConsDir(raw, currINFIdx) in
		(currINFIdx == 1 && seg2Len > 0) ? 
			asidForCurrSeg(dp, raw, numINF, seg1Len, seg1Len+seg2Len, seg1Len, consDir, asid, length) :
			(currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ? 
				asidForCurrSeg(dp, raw, numINF, seg1Len+seg2Len, seg1Len+seg2Len+seg3Len, seg1Len+seg2Len, consDir, asid, length) :
				some(seq[io.IO_as]{})
}

// returns a list of ASids of hopfields for RightSeg in the abstract packet
ghost
requires dp.Valid()
requires 1 <= numINF
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires 0 <= length && length <= len(raw)
requires hopFieldOffset(numINF, seg1Len + seg2Len + seg3Len) <= length
requires currINFIdx <= numINF + 1
requires -1 <= currINFIdx && currINFIdx < 2
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures (currINFIdx == 0 && res != none[seq[io.IO_as]]) ==> len(get(res)) == seg1Len
ensures (currINFIdx == 1 && seg2Len > 0 && res != none[seq[io.IO_as]]) ==> len(get(res)) == seg2Len
decreases
pure func asidsForRightSeg(dp io.DataPlaneSpec, raw []byte, numINF int, currINFIdx int, seg1Len int, seg2Len int, seg3Len int, asid io.IO_as, length int) (res option[seq[io.IO_as]]) {
	return (currINFIdx == 1 && seg2Len > 0) ? 
		let consDir := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in path.ConsDir(raw, currINFIdx) in
		asidForCurrSeg(dp, raw, numINF, seg1Len+seg2Len-1, seg1Len+seg2Len, seg1Len, consDir, asid, length) :
		(currINFIdx == 0) ? 
			let consDir := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in path.ConsDir(raw, currINFIdx) in
			asidForCurrSeg(dp, raw, numINF, seg1Len-1, seg1Len, 0, consDir, asid, length) :
			some(seq[io.IO_as]{})
}

// returns a list of ASids of hopfields for MidSeg in the abstract packet
ghost
requires dp.Valid()
requires 1 <= numINF
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires 0 <= length && length <= len(raw)
requires hopFieldOffset(numINF, seg1Len + seg2Len + seg3Len) <= length
requires currINFIdx <= numINF + 1
requires 2 <= currINFIdx && currINFIdx < 5
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
requires (currINFIdx == 4 && seg2Len > 0) ==> asid != none[io.IO_as]
requires (currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ==> asid != none[io.IO_as]
decreases
pure func asidsForMidSeg(dp io.DataPlaneSpec, raw []byte, numINF int, currINFIdx int, seg1Len int, seg2Len int, seg3Len int, asid option[io.IO_as], length int) (res option[seq[io.IO_as]]) {
	return (currINFIdx == 4 && seg2Len > 0) ? 
		let consDir := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in path.ConsDir(raw, 1) in
		asidForCurrSeg(dp, raw, numINF, seg1Len-1, seg1Len, 0, consDir, get(asid), length) :
		(currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ? 
			let consDir := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in path.ConsDir(raw, 2) in
			asidForCurrSeg(dp, raw, numINF, seg1Len + seg2Len, seg1Len + seg2Len + seg3Len, seg1Len + seg2Len, consDir, get(asid), length) :
			some(seq[io.IO_as]{})
}

ghost
requires 0 <= length && length <= len(raw)
requires idx + path.HopLen <= length
requires 0 <= idx
requires acc(&raw[idx+2], _) && acc(&raw[idx+3], _) && acc(&raw[idx+4], _) && acc(&raw[idx+5], _)
ensures  len(res.HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_) > 0
decreases
pure func hopField(raw []byte, idx int, beta set[io.IO_msgterm], asid io.IO_as, ainfo io.IO_ainfo, length int) (res io.IO_HF) {
	return let inif2 := binary.BigEndian.Uint16(raw[idx+2:idx+4]) in
		let egif2 := binary.BigEndian.Uint16(raw[idx+4:idx+6]) in
		let op_inif2 := inif2 == 0 ? none[io.IO_ifs] : some(io.IO_ifs(inif2)) in
		let op_egif2 := egif2 == 0 ? none[io.IO_ifs] : some(io.IO_ifs(egif2)) in
		let ts := io.IO_msgterm(io.MsgTerm_Num{ainfo}) in
		let l := io.IO_msgterm(io.MsgTerm_L{seq[io.IO_msgterm]{ts, io.if2term(op_inif2), io.if2term(op_egif2), 
			io.IO_msgterm(io.MsgTerm_FS{beta})}}) in
		let hvf := io.mac(io.macKey(io.asidToKey(asid)), l) in
		io.IO_HF(io.IO_HF_{
			InIF2 : op_inif2,
			EgIF2 : op_egif2,
			HVF : hvf,
		})
}

ghost 
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= len(asid)
requires 0 <= length && length <= len(raw)
requires  offset + path.HopLen * len(asid) <= length
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures   len(res) == len(asid) - currHFIdx
ensures   forall k int :: {res[k]} 0 <= k && k < len(res) ==> 
	len(res[k].HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_) > 0
decreases len(asid) - currHFIdx
pure func hopFieldsConsDir(
	raw []byte, 
	offset int, 
	currHFIdx int, 
	beta set[io.IO_msgterm], 
	asid seq[io.IO_as], 
	ainfo io.IO_ainfo, 
	length int) (res seq[io.IO_HF]) {
	return currHFIdx == len(asid) ? seq[io.IO_HF]{} : 
		let hf := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in 
			hopField(raw, offset + path.HopLen * currHFIdx, beta, asid[currHFIdx], ainfo, length)) in
		seq[io.IO_HF]{hf} ++ hopFieldsConsDir(raw, offset, currHFIdx + 1, (beta union set[io.IO_msgterm]{hf.HVF}), asid, ainfo, length)
}

ghost 
requires  0 <= offset 
requires  -1 <= currHFIdx && currHFIdx < len(asid)
requires 0 <= length && length <= len(raw)
requires  offset + path.HopLen * currHFIdx + path.HopLen <= length
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures   len(res) == currHFIdx + 1
ensures   forall k int :: {res[k]} 0 <= k && k < len(res) ==> 
	len(res[k].HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_) > 0
decreases currHFIdx + 1
pure func hopFieldsNotConsDir(
	raw []byte, 
	offset int, 
	currHFIdx int, 
	beta set[io.IO_msgterm], 
	asid seq[io.IO_as],
	ainfo io.IO_ainfo, 
	length int) (res seq[io.IO_HF]) {
	return currHFIdx == -1 ? seq[io.IO_HF]{} : 
		let hf := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in 
			hopField(raw, offset + path.HopLen * currHFIdx, beta, asid[currHFIdx], ainfo, length)) in
		hopFieldsNotConsDir(raw, offset, currHFIdx -1, (beta union set[io.IO_msgterm]{hf.HVF}), asid, ainfo, length) ++ seq[io.IO_HF]{hf}
}

ghost 
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
decreases currHFIdx + 1
pure func segPast(hopfields seq[io.IO_HF], currHFIdx int) seq[io.IO_HF] {
	return currHFIdx == -1  ?
		seq[io.IO_HF]{} : 
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segPast(hopfields, currHFIdx - 1)
}

ghost 
requires 0 <= currHFIdx && currHFIdx <= len(hopfields)
decreases len(hopfields) - currHFIdx
pure func segFuture(hopfields seq[io.IO_HF], currHFIdx int) seq[io.IO_HF] {
	return currHFIdx == len(hopfields) ? seq[io.IO_HF]{} : 
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segFuture(hopfields, currHFIdx + 1)
}

ghost 
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
decreases currHFIdx + 1
pure func segHistory(hopfields seq[io.IO_HF], currHFIdx int) seq[io.IO_ahi] {
	return currHFIdx == -1 ? seq[io.IO_ahi]{} : 
		seq[io.IO_ahi]{hopfields[currHFIdx].Toab()} ++ segHistory(hopfields, currHFIdx - 1)
			
}

ghost 
requires 0 <= offset
requires 0 < len(asid)
requires 0 <= length && length <= len(raw)
requires offset + path.HopLen * len(asid) <= length
requires 0 <= currHFIdx && currHFIdx <= len(asid)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
decreases 
pure func segment(raw []byte, 
	offset int, 
	currHFIdx int, 
	asid seq[io.IO_as], 
	ainfo io.IO_ainfo, 
	consDir bool, 
	peer bool, 
	length int) io.IO_seg2 {
	return let hopfields := consDir ?
		hopFieldsConsDir(raw, offset, 0, set[io.IO_msgterm]{}, asid, ainfo, length) : 
		hopFieldsNotConsDir(raw, offset, len(asid) - 1, set[io.IO_msgterm]{}, asid, ainfo, length) in
		let uinfo := uInfo(hopfields, currHFIdx, consDir) in
		io.IO_seg2(io.IO_seg3_{
			AInfo :ainfo,
			UInfo : uinfo,
			ConsDir : consDir,
			Peer : peer,
			Past : segPast(hopfields, currHFIdx - 1),
			Future : segFuture(hopfields, currHFIdx),
			History : segHistory(hopfields, currHFIdx - 1),
		})
}

ghost
requires path.InfoFieldOffset(currINFIdx) + path.InfoLen <= offset
requires 0 < len(asid)
requires 0 <= length && length <= len(raw)
requires offset + path.HopLen * len(asid) <= length
requires 0 <= currHFIdx && currHFIdx <= len(asid)
requires 0 <= currINFIdx && currINFIdx < 3
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
decreases 
pure func currSeg(raw []byte, offset int, currINFIdx int, currHFIdx int, asid seq[io.IO_as], length int) io.IO_seg3 {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in
		let ainfo := timestamp(raw, currINFIdx, length) in
		let consDir := path.ConsDir(raw, currINFIdx) in
		let peer := path.Peer(raw, currINFIdx) in
		segment(raw, offset, currHFIdx, asid, ainfo, consDir, peer, length)
}

ghost
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires 0 <= length && length <= len(raw)
requires pktLen(seg1Len, seg2Len, seg3Len) <= length
requires 1 <= currINFIdx && currINFIdx < 4
requires (currINFIdx == 1 && seg2Len > 0) ==> len(asid) == seg2Len
requires (currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ==> len(asid) == seg3Len
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
decreases 
pure func leftSeg(
	raw []byte, 
	currINFIdx int, 
	seg1Len int, 
	seg2Len int, 
	seg3Len int, 
	asid seq[io.IO_as],
	length int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) in
        (currINFIdx == 1 && seg2Len > 0) ? 
		some(currSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, 0, asid, length)) : 
		(currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ? 
			some(currSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, asid, length)) : 
			none[io.IO_seg3]
}

ghost
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires 0 <= length && length <= len(raw)
requires pktLen(seg1Len, seg2Len, seg3Len) <= length
requires -1 <= currINFIdx && currINFIdx < 2
requires (currINFIdx == 1 && seg2Len > 0 && seg3Len > 0) ==> len(asid) == seg2Len
requires (currINFIdx == 0 && seg2Len > 0) ==> len(asid) == seg1Len
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
decreases
pure func rightSeg(
	raw []byte, 
	currINFIdx int, 
	seg1Len int,
	seg2Len int, 
	seg3Len int, 
	asid seq[io.IO_as],
	length int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) in
    (currINFIdx == 1 && seg2Len > 0 && seg3Len > 0) ? 
		some(currSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, seg2Len, asid, length)) :
		(currINFIdx == 0 && seg2Len > 0) ? 
			some(currSeg(raw, offset, currINFIdx, seg1Len, asid, length)) : 
			none[io.IO_seg3]					
}

ghost
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires 0 <= length && length <= len(raw)
requires pktLen(seg1Len, seg2Len, seg3Len) <= length
requires 2 <= currINFIdx && currINFIdx < 5
requires (currINFIdx == 4 && seg2Len > 0) ==> len(asid) == seg1Len
requires (currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ==> len(asid) == seg3Len
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
decreases 
pure func midSeg(
	raw []byte, 
	currINFIdx int, 
	seg1Len int, 
	seg2Len int, 
	seg3Len int, 
	asid seq[io.IO_as], 
	length int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) in
        (currINFIdx == 4 && seg2Len > 0) ? 
		some(currSeg(raw, offset, 0, seg1Len, asid, length)) :
		(currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ? 
			some(currSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, asid, length)) : 
			none[io.IO_seg3]
}

ghost 
requires dp.Valid()
requires 4 < length && length <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
requires unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in 
	let hdr := binary.BigEndian.Uint32(raw[0:4]) in
    let metaHdr := scion.DecodedFrom(hdr) in
	let seg1 := int(metaHdr.SegLen[0]) in
	let seg2 := int(metaHdr.SegLen[1]) in
	let seg3 := int(metaHdr.SegLen[2]) in
    let base := scion.Base{metaHdr, 
        numInfoFields(seg1, seg2, seg3),
        seg1 + seg2 + seg3} in
    metaHdr.InBounds() &&
    0 < metaHdr.SegLen[0] &&
    base.ValidCurrInfSpec() &&
    base.ValidCurrHfSpec() &&
    length == pktLen(seg1, seg2, seg3)
decreases 
pure func absPkt(dp io.DataPlaneSpec, raw []byte, asid io.IO_as, length int) option[io.IO_pkt2] {
	return let hdr := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in binary.BigEndian.Uint32(raw[0:4]) in
		let metaHdr := scion.DecodedFrom(hdr) in
        let currINFIdx := int(metaHdr.CurrINF) in
		let currHFIdx := int(metaHdr.CurrHF) in
		let seg1Len := int(metaHdr.SegLen[0]) in
		let seg2Len := int(metaHdr.SegLen[1]) in 
		let seg3Len := int(metaHdr.SegLen[2]) in
		let segLen := lengthOfCurrSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let prevSegLen := lengthOfPrevSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let numINF := numInfoFields(seg1Len, seg2Len, seg3Len) in
		let offset := hopFieldOffset(numINF, 0) in
		let consDir := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in path.ConsDir(raw, currINFIdx) in
		let currAsidSeq := asidForCurrSeg(dp, raw, numINF, currHFIdx, prevSegLen+segLen, prevSegLen, consDir, dp.Asid(), length) in
		currAsidSeq == none[seq[io.IO_as]] ? none[io.IO_pkt2] : some(io.IO_pkt2(io.IO_Packet2{}))
			/*let last := get(currAsidSeq)[segLen-1] in
			let first := get(currAsidSeq)[0] in
			let leftAsidSeq := asidsForLeftSeg(dp, raw, numINF, currINFIdx + 1, seg1Len, seg2Len, seg3Len, last, length) in
			let rightAsidSeq := asidsForRightSeg(dp, raw, numINF, currINFIdx - 1, seg1Len, seg2Len, seg3Len, first, length) in
			(leftAsidSeq == none[seq[io.IO_as]] || rightAsidSeq == none[seq[io.IO_as]]) ? none[io.IO_pkt2] :
				let midAsid := ((currINFIdx == 0 && seg2Len > 0 && seg3Len > 0) ? some(get(leftAsidSeq)[len(get(leftAsidSeq))-1]) :
					(currINFIdx == 2 && seg2Len > 0) ? some(get(rightAsidSeq)[0]) : none[io.IO_as]) in
				let midAsidSeq := asidsForMidSeg(dp, raw, numINF, currINFIdx + 2, seg1Len, seg2Len, seg3Len, midAsid, length) in
				midAsidSeq == none[seq[io.IO_as]] ? none[io.IO_pkt2] :
					some(io.IO_pkt2(io.IO_Packet2{
						CurrSeg : io.IO_seg2(io.IO_seg3_{}), // currSeg(raw, offset+prevSegLen, currINFIdx, currHFIdx-prevSegLen, get(currAsidSeq), length),
						LeftSeg : none[io.IO_seg3], //leftSeg(raw, currINFIdx + 1, seg1Len, seg2Len , seg3Len, get(leftAsidSeq), length),
						MidSeg : none[io.IO_seg3], //midSeg(raw, currINFIdx + 2, seg1Len, seg2Len , seg3Len, get(midAsidSeq), length),
						RightSeg : none[io.IO_seg3], //rightSeg(raw, currINFIdx - 1, seg1Len, seg2Len , seg3Len, get(rightAsidSeq), length),
					}))*/
}


ghost 
requires 0 <= offset
requires 0 < length && length <= len(raw)
requires path.InfoFieldOffset(offset) + 8 < length
requires acc(&raw[path.InfoFieldOffset(offset) + 4], _)
requires acc(&raw[path.InfoFieldOffset(offset) + 5], _)
requires acc(&raw[path.InfoFieldOffset(offset) + 6], _)
requires acc(&raw[path.InfoFieldOffset(offset) + 7], _)
decreases
pure func timestamp(raw []byte, offset int, length int) io.IO_ainfo {
	return let idx := path.InfoFieldOffset(offset) + 4 in 
		io.IO_ainfo(binary.BigEndian.Uint32(raw[idx : idx + 4]))
}

ghost
requires len(hopfield.HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_) > 0
decreases
pure func hvfSet(hopfield io.IO_HF) set[io.IO_msgterm] {
	return let l := hopfield.HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_ in
		l[len(l) - 1].MsgTerm_FS_
}

ghost
requires 0 < len(hopfields)
requires 0 <= currHFIdx && currHFIdx <= len(hopfields)
requires forall idx int :: {hopfields[idx]} 0 <= idx && idx < len(hopfields) ==>
	len(hopfields[idx].HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_) > 0
decreases
pure func uInfo(hopfields seq[io.IO_HF], currHFIdx int, consDir bool) set[io.IO_msgterm] {
	return currHFIdx == len(hopfields) ?
		hvfSet(hopfields[currHFIdx-1]) :
		(currHFIdx == 0 ?
				hvfSet(hopfields[currHFIdx]) :
				(consDir ?
						hvfSet(hopfields[currHFIdx]) :
						hvfSet(hopfields[currHFIdx-1])))
}

ghost
decreases
pure func ifsToIO_ifs(ifs uint16) option[io.IO_ifs]{
    return ifs == 0 ? none[io.IO_ifs] : some(io.IO_ifs(ifs))
}

ghost 
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
decreases
pure func validPktMetaHdr(raw []byte, length int) bool {
	return 4 < length && length <= len(raw) && 
		unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in 
		let hdr := binary.BigEndian.Uint32(raw[0:4]) in
		let metaHdr := scion.DecodedFrom(hdr) in
		let seg1 := int(metaHdr.SegLen[0]) in
		let seg2 := int(metaHdr.SegLen[1]) in
		let seg3 := int(metaHdr.SegLen[2]) in
		let base := scion.Base{metaHdr, 
			numInfoFields(seg1, seg2, seg3),
			seg1 + seg2 + seg3} in
		metaHdr.InBounds() &&
		0 < metaHdr.SegLen[0] &&
		base.ValidCurrInfSpec() &&
		base.ValidCurrHfSpec() &&
		length == pktLen(seg1, seg2, seg3)
}

ghost 
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures val.isIO_val_Unsupported
ensures val.IO_val_Unsupported_1 == ifsToIO_ifs(ingressID)
decreases
pure func absIO_val_Unsupported(raw []byte, ingressID uint16) (ghost val io.IO_val)

ghost
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _)
ensures val.isIO_val_Pkt2 || val.isIO_val_Unsupported
decreases
pure func absIO_val(dp io.DataPlaneSpec, raw []byte, ingressID uint16, length int) (ghost val io.IO_val) {
	return (validPktMetaHdr(raw, length) && absPkt(dp, raw, dp.asid(), length) != none[io.IO_pkt2]) ? 
		io.IO_val(io.IO_val_Pkt2{ifsToIO_ifs(ingressID), get(absPkt(dp, raw, dp.asid(), length))}) : 
		absIO_val_Unsupported(raw, ingressID)
}


ghost
decreases 
func absIO_valDummy() (io.IO_val)


ghost
requires dp.Valid()
requires sl.AbsSlice_Bytes(raw, 0, len(raw))
//requires sl.AbsSlice_Bytes(raw2, 0, len(raw2))
requires 0 <= length && length <= len(raw)
requires validPktMetaHdr(raw, length)
requires es_val == absPkt(dp, raw, dp.asid(), length)
//requires forall i int :: {&raw2[i]} {&raw1[i]} 0 <= i && i < len(raw1) ==> (unfolding acc(sl.AbsSlice_Bytes(raw1, 0, len(raw1)), _) in raw1[i]) == (unfolding acc(sl.AbsSlice_Bytes(raw2, 0, len(raw2)), _) in raw2[i])
decreases 
func simpletest(dp io.DataPlaneSpec, raw []byte, ingressID uint16, length int, es_val option[io.IO_pkt2]) {
	sl.SplitRange_Bytes(raw, 0, length, 1/2)
	assert acc(sl.AbsSlice_Bytes(raw[:length], 0, length), 1/2)
	unfold acc(sl.AbsSlice_Bytes(raw[:length], 0, length), 1/2)
	assert forall i int :: { &raw[i] } 0 <= i && i < length ==> raw[i] == (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), 1/2) in raw[i])
	assert forall i int :: { &raw[i] } 0 <= i && i < length ==> raw[i] == old(unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), 1/2) in raw[i])
	fold acc(sl.AbsSlice_Bytes(raw[:length], 0, length), 1/2)
	// validPktMetaHdr(raw, length) && absPkt(dp, raw, dp.asid(), length)
	//assert validPktMetaHdr(raw, length) == validPktMetaHdr(raw[:length], length)
	//assume validPktMetaHdr(raw, length)
	//assert es_val == absPkt(dp, raw[:length], dp.asid(), length)
	// assert forall i int ::  { &s[:5][i] } 0 <= i && i < 5 ==> s[:5][i] == old(unfolding AbsSlice_Bytes(s, 0, len(s)) in s[i])
	//assert forall i int :: 0 <= i && i < len(raw1) ==> (unfolding acc(sl.AbsSlice_Bytes(raw1, 0, len(raw1)), 1/2) in raw1[i]) == (unfolding acc(sl.AbsSlice_Bytes(raw2, 0, len(raw2)), 1/2) in raw2[i])
	//assert absIO_val_abstract(dp, raw1, len(raw1)) == absIO_val_abstract(dp, raw2[:len(raw1)], len(raw1))
	hdr1 := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in binary.BigEndian.Uint32(raw[0:4])
	metaHdr1 := scion.DecodedFrom(hdr1)
	currINFIdx1 := int(metaHdr1.CurrINF)
	currHFIdx1 := int(metaHdr1.CurrHF)
	seg1Len1 := int(metaHdr1.SegLen[0])
	seg2Len1 := int(metaHdr1.SegLen[1])
	seg3Len1 := int(metaHdr1.SegLen[2])
	segLen1 := lengthOfCurrSeg(currHFIdx1, seg1Len1, seg2Len1, seg3Len1)
	prevSegLen1 := lengthOfPrevSeg(currHFIdx1, seg1Len1, seg2Len1, seg3Len1)
	numINF1 := numInfoFields(seg1Len1, seg2Len1, seg3Len1)
	offset1 := hopFieldOffset(numINF1, 0)
	consDir1 := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in path.ConsDir(raw, currINFIdx1)
	currAsidSeq1 := asidForCurrSeg(dp, raw, numINF1, currHFIdx1, prevSegLen1+segLen1, prevSegLen1, consDir1, dp.Asid(), length)
	hdr2 := unfolding acc(sl.AbsSlice_Bytes(raw[:length], 0, length), _) in binary.BigEndian.Uint32(raw[:length][0:4])
	metaHdr2 := scion.DecodedFrom(hdr2)
	currINFIdx2 := int(metaHdr2.CurrINF)
	currHFIdx2 := int(metaHdr2.CurrHF)
	seg1Len2 := int(metaHdr2.SegLen[0])
	seg2Len2 := int(metaHdr2.SegLen[1])
	seg3Len2 := int(metaHdr2.SegLen[2])
	segLen2 := lengthOfCurrSeg(currHFIdx2, seg1Len2, seg2Len2, seg3Len2)
	prevSegLen2 := lengthOfPrevSeg(currHFIdx2, seg1Len2, seg2Len2, seg3Len2)
	numINF2 := numInfoFields(seg1Len2, seg2Len2, seg3Len2)
	offset2 := hopFieldOffset(numINF2, 0)
	consDir2 := unfolding acc(sl.AbsSlice_Bytes(raw[:length], 0, length), _) in path.ConsDir(raw, currINFIdx2)
	currAsidSeq2 := asidForCurrSeg(dp, raw[:length], numINF2, currHFIdx2, prevSegLen2+segLen2, prevSegLen2, consDir2, dp.Asid(), length)
	assert hdr1 == hdr2 
	assert metaHdr1 == metaHdr2 
	assert currINFIdx1 == currINFIdx2
	assert currHFIdx1 == currHFIdx2 
	assert seg1Len1 == seg1Len2 
	assert seg2Len1 == seg2Len2
	assert seg3Len1 == seg3Len2 
	assert segLen1 == segLen2 
	assert prevSegLen1 == prevSegLen2
	assert numINF1 == numINF2 
	assert offset1 == offset2 
	assert consDir1 == consDir2
	assert (currAsidSeq1 != none[seq[io.IO_as]] && currAsidSeq2 != none[seq[io.IO_as]]) ==> len(get(currAsidSeq1)) == len(get(currAsidSeq2))
}
/*
ghost
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), 1/2)
requires 0 <= length && length <= len(raw)
decreases
pure func absIO_val_abstract(dp io.DataPlaneSpec, raw []byte, length int) (ghost val io.IO_val)
{
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), _) in absIO_val_abstract2(raw[:length], length)
}


ghost
requires 0 <= length && length <= len(raw)
requires forall i int :: { &raw[i] } 0 <= i && i < len(raw) ==> acc(&raw[i])
decreases
pure func absIO_val_abstract2(raw []byte, length int) (ghost val io.IO_val)
*/