// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"sync"
	io "github.com/scionproto/scion/verification/io"
)

type SharedArg struct {
	Place *io.Place // Existential for the current place
	State *io.IO_dp3s_state_local // Existential for the current model state
	IBufY, OBufY ElemRA // Parameters of the resoure algebra (is not necessary to understand to verify I/O spec)
}

pred SharedInv(ghost dp io.DataPlaneSpec, ghost y SharedArg) {
	acc(y.Place) && acc(y.State) && // existentials are expressed using ghost pointers
	io.token(*y.Place) && dp.dp3s_iospec_ordered(*y.State, *y.Place) && 
	ElemAuth((*y.State).ibuf, y.IBufY) && ElemAuth((*y.State).obuf, y.OBufY)
}

// initialize the shared invariant:
ghost 
requires io.token(p) && dp.dp3s_iospec_ordered(s, p)
ensures  m.LockP() && m.LockInv() == SharedInv!< dp, y !>;
func InitSharedInv(ghost dp io.DataPlaneSpec, ghost p io.Place, ghost s io.IO_dp3s_state_local) (ghost m *sync.Mutex, ghost y SharedArg) {
	mV@ := sync.Mutex{}
	m = &mV
	pE@ := p
	sE@ := s
	yI := InitElemAuth(s.ibuf)
	yO := InitElemAuth(s.obuf)
	y := SharedArg{&pE, &sE, yI, yO}
	fold SharedInv!< dp, y !>()
	m.SetInv(SharedInv!< dp, y !>)
}

/////////////////////////////////////// Lib ///////////////////////////////////////

pred Prophecy(int)

ghost
ensures 0 <= expectedM && Prophecy(expectedM)
decreases
func AllocProphecy() (expectedM int)

/////////////////////////////////////// MultiBio ///////////////////////////////////////

pred MultiReadBio(ghost t io.Place, n int) {
  (n > 0 ==> io.CBioIO_bio3s_recv(t) && MultiReadBio(io.dp3s_iospec_bio3s_recv_T(t), n-1))
}

ghost
requires m <= n && MultiReadBio(t, n)
decreases m
pure func MutliReadBio_next(ghost t io.Place, n, m int) (ghost tn io.Place) {
  return m <= 0 ? t : unfolding MultiReadBio(t, n) in 
    MutliReadBio_next(io.dp3s_iospec_bio3s_recv_T(t), n-1, m-1)
}

ghost 
requires m <= n && MultiReadBio(t, n)
decreases m
pure func MutliReadBio_correctIfs(ghost t io.Place, n, m int, ghost k Key) bool {
  return m <= 0 ? true : unfolding MultiReadBio(t, n) in 
    match io.dp3s_iospec_bio3s_recv_R(t){
      case io.IO_val_Unsupported{?ifs, _}:
        k == ifs
      case io.IO_val_Pkt2{?ifs, _ }:
        k == ifs
      default:
        false
    } && MutliReadBio_correctIfs(io.dp3s_iospec_bio3s_recv_T(t), n-1, m-1, k)
}

ghost
requires io.CBioIO_bio3s_recv(t)
decreases
pure func IO_valToIO_Pkt3(ghost t io.Place) (ghost res seq[Elem]) {
  return let pkt := io.dp3s_iospec_bio3s_recv_R(t) in
    match pkt{
      case io.IO_val_Pkt2{_, _}:
        seq[Elem]{pkt.IO_val_Pkt2_2}
      default:
        seq[Elem]{}
    }
}

ghost 
requires  0 <= m && m <= n && MultiReadBio(t, n)
ensures len(res) == m
decreases m
pure func MutliReadBio_IO_val(ghost t io.Place, n, m int) (ghost res seq[io.IO_val]) {
  return m <= 0 ? seq[io.IO_val]{} : unfolding MultiReadBio(t, n) in 
    seq[io.IO_val]{io.dp3s_iospec_bio3s_recv_R(t)} ++ MutliReadBio_IO_val(
      io.dp3s_iospec_bio3s_recv_T(t), n-1, m-1)
}

ghost 
requires m <= n && MultiReadBio(t,n)
decreases m
pure func MultiReadBio_Upd(ghost t io.Place, n, m int, ghost s io.IO_dp3s_state_local) io.IO_dp3s_state_local {
  return m <= 0 ? s : unfolding MultiReadBio(t, n) in 
    MultiReadBio_Upd(io.dp3s_iospec_bio3s_recv_T(t), n-1, m-1, add_ibuf(s, io.dp3s_iospec_bio3s_recv_R(t)))
}

ghost 
decreases 
pure func add_ibuf(s io.IO_dp3s_state_local, val io.IO_val) io.IO_dp3s_state_local {
 return match val {
  case io.IO_val_Pkt2{?ifs, ?pkt}: 
    io.dp3s_add_ibuf(s, ifs, pkt)
  case io.IO_val_Unsupported{_, _}:
    s
  default:
    io.undefined()
 }
}

ghost 
decreases len(es)
pure func MultiIBuf_Upd(ghost es seq[io.IO_val], ghost s io.IO_dp3s_state_local) io.IO_dp3s_state_local {
  return len(es) == 0 ? s : MultiIBuf_Upd(es[1:], add_ibuf(s, es[0]))
}

ghost
decreases n
requires dp.dp3s_iospec_ordered(s,t)
ensures  MultiReadBio(t,n) && dp.dp3s_iospec_ordered(MultiReadBio_Upd(t,n,n,s), MutliReadBio_next(t,n,n))
func ExtractMultiReadBio(ghost dp io.DataPlaneSpec, ghost t io.Place, n int, ghost s io.IO_dp3s_state_local) {
  if n > 0 {
    unfold dp.dp3s_iospec_ordered(s,t)
    unfold dp.dp3s_iospec_bio3s_recv(s,t)
    ExtractMultiReadBio(dp, io.dp3s_iospec_bio3s_recv_T(t), n-1, add_ibuf(s, io.dp3s_iospec_bio3s_recv_R(t)))
  } 
  fold MultiReadBio(t,n)
}

ghost 
requires MultiReadBio(t,n)
requires ElemAuth(s.ibuf, y.IBufY) && ElemAuth(s.obuf, y.OBufY)
ensures  MultiReadBio(t,n)
ensures  ElemAuth(MultiReadBio_Upd(t,n,n,s).ibuf, y.IBufY) && ElemAuth(MultiReadBio_Upd(t,n,n,s).obuf, y.OBufY)
ensures  0 <= m && m <= n && MutliReadBio_correctIfs(t,n,m,k) ==> MultiElemWitness(y.IBufY, k, MutliReadBio_IO_val(t,n,m))
decreases n
func MultiUpdateElemWitness2(ghost t io.Place, n, m int, ghost k Key, ghost s io.IO_dp3s_state_local, ghost y SharedArg) {
  if n > 0 {
    unfold MultiReadBio(t,n)
    val := io.dp3s_iospec_bio3s_recv_R(t)
    next := io.dp3s_iospec_bio3s_recv_T(t)
    if val.isIO_val_Pkt2{
      UpdateElemWitness(s.ibuf, y.IBufY, val.IO_val_Pkt2_1, val.IO_val_Pkt2_2)
    }
    MultiUpdateElemWitness2(next, n-1, m-1, k, add_ibuf(s, val), y)
    fold MultiReadBio(t,n)
  } 
  
  if 0 <= m && m <= n && MutliReadBio_correctIfs(t,n,m,k) {
    fold MultiElemWitness(y.IBufY, k, MutliReadBio_IO_val(t,n,m))
  }
}

pred MultiElemWitness(ghost y ElemRA, ghost k Key, ghost es seq[io.IO_val]) { 
  // cannot be quantified because there might be multiple witnesses for the same element
  len(es) > 0 ==> match es[0] {
    case io.IO_val_Pkt2{_, _}:
      ElemWitness(y, k, es[0].IO_val_Pkt2_2)
    default: 
      true
  } && MultiElemWitness(y, k, es[1:])
}

pred MultiElemWitness0(ghost y ElemRA, ghost k Key, ghost es seq[io.IO_val], i int) { 
  0 <= i && i < len(es) ==> match es[i] {
    case io.IO_val_Pkt2{_, _}:
       ElemWitness(y, k, es[i].IO_val_Pkt2_2)
    default: 
      true
  } && MultiElemWitness0(y, k, es, i+1)
}

ghost 
decreases 
requires MultiElemWitness(y,k,es)
ensures  MultiElemWitness0(y,k,es,0)
func MultiElemWitnessConv(ghost y ElemRA, ghost k Key, ghost es seq[io.IO_val]) {
  multiElemWitnessConvAux(y,k,es,0)
}

ghost
requires i >= 0 
requires MultiElemWitness(y,k,es[i:])
ensures  MultiElemWitness0(y,k,es,i)
decreases len(es)-i
func multiElemWitnessConvAux(ghost y ElemRA, ghost k Key, ghost es seq[io.IO_val], i int) {
  unfold MultiElemWitness(y,k,es[i:])
  if i < len(es) {
    multiElemWitnessConvAux(y,k,es,i+1)
  }
  fold MultiElemWitness0(y,k,es,i)
}

/////////////////////////////////////// RA definitions ///////////////////////////////////////
type Key = option[io.IO_ifs]
type Val = set[io.IO_pkt3]
type Elem = io.IO_pkt3

type ElemRA domain{} 

pred ElemAuth(ghost m dict[Key]Val, ghost y ElemRA) 

pred ElemWitness(ghost y ElemRA, ghost k Key, ghost e Elem) 

ghost
decreases 
requires ElemAuth(m, y) && ElemWitness(y, k, e)
ensures  ElemAuth(m, y) && ElemWitness(y, k, e) && k in domain(m) && e in AsSet(m[k])
func ApplyElemWitness(ghost m dict[Key]Val, ghost y ElemRA, ghost k Key, ghost e Elem) 

ghost 
decreases
requires ElemAuth(m, y) 
ensures  ElemAuth(io.insert(m, k, e), y) && ElemWitness(y, k, e)
func UpdateElemWitness(ghost m dict[Key]Val, ghost y ElemRA, ghost k Key, ghost e Elem) 

ghost
decreases
ensures ElemAuth(m, y)
func InitElemAuth(ghost m dict[Key]Val) (ghost y ElemRA) 


/////////////////////////////////////// Utility ///////////////////////////////////////

ghost 
decreases
pure func AsSet(s set[Elem]) set[Elem] {
	return s
}