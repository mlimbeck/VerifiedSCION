// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"sync"
	io "github.com/scionproto/scion/verification/io"
  sl "github.com/scionproto/scion/verification/utils/slices"
)

//TODO remove
ghost
decreases
ensures ElemWitness(y, k, e)
func AssumeElemWitness(ghost y ElemRA, ghost k Key, ghost e Elem)


ghost
decreases
pure func ifsToIO_ifs(ifs uint16) option[io.IO_ifs]{
    return ifs == 0 ? none[io.IO_ifs] : some(io.IO_ifs(ifs))
}

ensures PktMem(newpkt)
func check(p Pkt) (newpkt *int, uint16)

type Pkt *int 
pred PktMem(Pkt)

ghost
decreases
requires PktMem(p)
ensures e.isIO_val_Pkt2 || e.isIO_val_Unsupported
pure func IO_val_Abs(p Pkt) (ghost e io.IO_val)

/*
ghost
decreases
requires sl.AbsSlice_Bytes(pkt, 0, len(pkt))
ensures e.isIO_val_Pkt2 || e.isIO_val_Unsupported
ensures len(pkt) >= slayers.CmnHdrLen && unfolding sl.AbsSlice_Bytes(pkt, 0, len(pkt)) in path.Type(pkt[8]) == scion.PathType ==> e.isIO_val_Pkt2
ensures BytesToPkt(pkt) == e.IO_val_Pkt2_2
pure func IO_val_Abs2(pkt [] byte) (ghost e io.IO_val)
*/
ghost 
decreases
requires sl.AbsSlice_Bytes(pkt, 0, len(pkt))
pure func BytesToPkt(pkt [] byte) (io.IO_pkt3)

decreases 
requires Prophecy(prophecyM)
requires io.token(t) && MultiReadBio(t, prophecyM)
requires forall i int :: {&buf[i]} 0 <= i && i < len(buf) ==> acc(&buf[i])
ensures  prophecyM == m
ensures  0 <= m && m <= len(buf) 
ensures  io.token(old(MutliReadBio_next(t, m, m))) && old(MutliReadBio_correctIfs(t, m, m, ifsToIO_ifs(c)))
ensures  forall i int :: {&buf[i]} 0 <= i && i < len(buf) ==> acc(&buf[i])
ensures  forall i int :: 0 <= i && i < m ==> PktMem(buf[i]) && IO_val_Abs(buf[i]) == old(MutliReadBio_IO_val(t, m, m)[i])
func BatchRecv(c uint16, buf []Pkt, ghost prophecyM int, ghost t io.Place) (m int)

//----------------------------------------------------------------------//

requires dp.Valid()
requires io.token(p) && dp.dp3s_iospec_ordered(s, p)
func rc (ingressID uint16, ghost p io.Place, ghost s io.IO_dp3s_state_local, ghost dp io.DataPlaneSpec) {
  ghost m, y := InitSharedInv(dp, p, s)
  ghost from := ifsToIO_ifs(ingressID)
  buf := make([]Pkt, 1000)

invariant acc(m.LockP(), _) && m.LockInv() == SharedInv!< dp, y !>;
invariant forall i int :: {&buf[i]} 0 <= i && i < len(buf) ==> acc(&buf[i])
for true {
    ghost n := len(buf)
    // multi recv
    ghost m.Lock()
    unfold SharedInv!< dp, y !>()

    ghost t, s := *y.Place, *y.State
    ghost numberOfReceivedPacketsProphecy := AllocProphecy() 
    ExtractMultiReadBio(dp, t, numberOfReceivedPacketsProphecy, s)
    MultiUpdateElemWitness2(t, numberOfReceivedPacketsProphecy, numberOfReceivedPacketsProphecy, from, s, y)
    ghost es_val := MutliReadBio_IO_val(t,numberOfReceivedPacketsProphecy, numberOfReceivedPacketsProphecy)

    ghost sN := MultiReadBio_Upd(t,numberOfReceivedPacketsProphecy, numberOfReceivedPacketsProphecy, s)
    ghost tN := MutliReadBio_next(t, numberOfReceivedPacketsProphecy, numberOfReceivedPacketsProphecy)
    assert dp.dp3s_iospec_ordered(sN, tN)
    pkts := BatchRecv(ingressID, buf, numberOfReceivedPacketsProphecy, t)
    
    MultiElemWitnessConv(y.IBufY, from, es_val)
    //assert forall i int :: {es_val[i]} 0 <= i && i < pkts ==> PktMem(buf[i]) && IO_val_Abs(buf[i]) == es_val[i]
    //assert MultiElemWitness0(y.IBufY, from, es_val, 0)

    ghost *y.State = sN
    ghost *y.Place = tN

    fold SharedInv!< dp, y !>()
    m.Unlock()
    //end of recv
    
    if pkts == 0{
        continue
    }
    ghost k := 0

    invariant ifsToIO_ifs(ingressID) == from
    invariant acc(m.LockP(), _) && m.LockInv() == SharedInv!< dp, y !>;
    invariant forall i int :: {&buf[i]} 0 <= i && i < len(buf) ==> acc(&buf[i])
    invariant forall i int :: {buf[i]} k <= i && i < pkts ==> PktMem(buf[i]) && IO_val_Abs(buf[i]) == es_val[i]
    invariant MultiElemWitness0(y.IBufY, from, es_val, k)
    for _, p := range buf[:pkts] with k {
      unfold MultiElemWitness0(y.IBufY, from, es_val, k)
      assume IO_val_Abs(p).isIO_val_Pkt2
      ghost newPkt := processPkt(p, ingressID, m, y, dp)
      assume newPkt.isIO_val_Pkt2

      //send
      ghost m.Lock()
      unfold SharedInv!< dp, y !>()

      t, s := *y.Place, *y.State

      ApplyElemWitness(s.obuf, y.OBufY, newPkt.IO_val_Pkt2_1, newPkt.IO_val_Pkt2_2)
      assert newPkt.IO_val_Pkt2_2 in AsSet(s.obuf[newPkt.IO_val_Pkt2_1])
      
      assert dp.dp3s_iospec_bio3s_send_guard(s, t, newPkt)

      unfold dp.dp3s_iospec_ordered(s, t)
      unfold dp.dp3s_iospec_bio3s_send(s, t)

      tN := io.dp3s_iospec_bio3s_send_T(t, newPkt)
      io.Send(t, newPkt)
      
      ghost *y.Place = tN
      
      fold SharedInv!< dp, y !>()
      ghost m.Unlock()
    }
  }
}

requires dp.Valid()
requires PktMem(p)
requires acc(m.LockP(), _) && m.LockInv() == SharedInv!< dp, y !>;
requires IO_val_Abs(p).isIO_val_Pkt2 ==> ElemWitness(y.IBufY, ifsToIO_ifs(ingressID), IO_val_Abs(p).IO_val_Pkt2_2)
ensures PktMem(p)
ensures newPkt.isIO_val_Pkt2 ==> ElemWitness(y.OBufY, newPkt.IO_val_Pkt2_1, newPkt.IO_val_Pkt2_2)
func processPkt(p Pkt, ghost ingressID uint16, ghost m *sync.Mutex, ghost y SharedArg, ghost dp io.DataPlaneSpec) (ghost newPkt io.IO_val) {
  var pathType int
  assume IO_val_Abs(p).isIO_val_Pkt2 ==> pathType == 1
  assume pathType == 1 ==> IO_val_Abs(p).isIO_val_Pkt2
  if pathType == 1 {
    //assume ifsToIO_ifs(ingressID) == IO_val_Abs(p).IO_val_Pkt2_1
    //Process(p, ingressID, m, y)
    assume newPkt.isIO_val_Pkt2
    AssumeElemWitness(y.OBufY, newPkt.IO_val_Pkt2_1, newPkt.IO_val_Pkt2_2)
  } else {
    assume !newPkt.isIO_val_Pkt2
  }
  return newPkt
}
